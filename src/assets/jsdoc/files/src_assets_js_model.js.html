<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\assets\js\model.js - GCCI Model API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="..\..\imgs\jsdoc_logo.jpg" title="GCCI Model API"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/GCCIModel.html">GCCIModel</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\assets\js\model.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * ------------------------------------------
 * Name:    GCCI Model Script
 * Version: 1.0.0
 * Author:  PZ
 * Date:    2015-10-15
 * ------------------------------------------
 *
 * Change Log:
 *
 * 1.0.0 (2015-10-15)
 * - added basic model structure
 */

/**
 * GCCI Model
 *
 * @class GCCIModel
 */
class GCCIModel {
    constructor() {
        this.rootRef = new Firebase(&quot;https://gcci-model.firebaseio.com/&quot;);
        this.nodes = [];

        this.init();
    }

    init() {
        this.rootRef.on(&quot;value&quot;, (snapshot) =&gt; {
            let nodeObjs = snapshot.val();

            if (nodeObjs !== null) {
                for (let key of Object.keys(nodeObjs)) {
                    let data = nodeObjs[key];
                    data[id] = key;
                    this.nodes.push(data);
                }
            }
        });
    }

    /**
     * Gets tree data structure with DFS.
     *
     * @method getTree
     * @return {Array} an array of nodes
     */
    static getTree() {

    }

    /**
     * Gets the children nodes of the given node.
     *
     * @method getChildren
     * @param {Object} node given node
     * @returns {Array} children nodes
     */
    static getChildren(node) {
        let children = [];

        for (let n of this.nodes) {
            if (getParentPath(n) === node.path) {
                children.push(n);
            }
        }

        return children;
    }

    /**
     * Gets the descendants nodes of the give node.
     *
     * @method getDescendants
     * @param {Object} node given node
     * @returns {Array} descendants nodes
     */
    static getDescendants(node) {
        let descendants = [];

        for (let n of this.nodes) {
            if (getPathAtDepth(n.path, getDepth(node.path)) === node.path &amp;&amp; getDepth(n.path) &gt; getDepth(node.path)) {
                descendants.push(n);
            }
        }

        return descendants;
    }

    /**
     * Gets the parent node of the given node.
     *
     * @method getParent
     * @param {Object} node given node
     * @returns {Object} parent node
     */
    static getParent(node) {
        let parentPath = getParentPath(node);

        return this.nodes.find(x =&gt; x.path === parentPath);
    }

    /**
     * Gets the siblings nodes of the given node.
     *
     * @method getSiblings
     * @param {Object} node given node
     * @returns {Array} siblings nodes
     */
    static getSiblings(node) {
        let siblings = [],
            parentPath = getParentPath(node);

        for (let n of this.nodes) {
            if (parentPath === getParentPath(n)) {
                siblings.push(n);
            }
        }
        siblings.sort((a, b) =&gt; a.path.localeCompare(b.path));

        return siblings;
    }

    /**
     * Adds a new node as a child to the given node.
     * The new node will be the new rightmost child.
     * If you want to insert a node at a specific position, use the addSibling() method.
     *
     * @method addChild
     * @param {Object} target target node
     * @param {Object} data new node&#x27;s data
     */
    static addChild(target, data) {
        let childPath = calcPathAppend(target.path, indexToPath(getChildren(target).length + 1));

        this.rootRef.push().set({
            &quot;title&quot;: data.title,
            &quot;uid&quot;: data.uid,
            &quot;path&quot;: childPath
        });
    }

    /**
     * Adds a new node as a sibling to the target node object.
     *
     * @method addSibling
     * @param {Object} target target node
     * @param {String} pos possible values are: first, last, left, right
     * @param {Object} data new node&#x27;s data
     */
    static addSibling(target, pos, data) {
        let [siblings, parentPath, newNodePath] = [
            getSiblings(target),
            getParentPath(target),
            &quot;&quot;
        ];

        // shift target&#x27;s siblings
        if (pos === &quot;first&quot;) {
            newNodePath = calcPathAppend(parentPath, indexToPath(1));
            for (let s of siblings) {
                updatePath(s, calcPathShift(s.path, 1));
            }
        }
        else if (pos === &quot;last&quot;) {
            newNodePath = calcPathAppend(parentPath + indexToPath(siblings.length + 1));
        }
        else if (pos === &quot;left&quot; || pos === &quot;right&quot;) {
            newNodePath = pos === &quot;left&quot; ? target.path : calcPathShift(target.path, 1);
            for (let s of siblings) {
                if (getPathIndex(s.path) &gt;= getPathIndex(newNodePath)) {
                    updatePath(s, calcPathShift(s.path, 1));
                }
            }
        }

        // insert new node
        if (newNodePath !== &quot;&quot;) {
            this.rootRef.push().set({
                &quot;title&quot;: data.title,
                &quot;uid&quot;: data.uid,
                &quot;path&quot;: newNodePath
            });
        }
        else {
            throw &quot;Invalid path&quot;;
        }
    }

    /**
     * Removes the given node and all its descendants.
     *
     * @method remove
     * @param {Object} node given node
     */
    static remove(node) {
        let [descendants, siblings, pathIndex] = [
            getDescendants(node),
            getSiblings(node),
            getPathIndex(node.path)
        ];

        for (let d of descendants) {
            getRefById(d.id).remove();
        }
        getRefById(node.id).remove();

        // update path of its right siblings
        for (let s of siblings) {
            if (getPathIndex(s.path) &gt; pathIndex) {
                updatePath(s, calcPathShift(s.path, -1));
            }
        }
    }

    /**
     * Moves the given node and all its descendants to a new position relative to another node.
     *
     * @method move
     * @param {Object} node given node
     * @param {Object} target target node
     * @param {String} pos possible values are: child, left, right
     */
    static move(node, target, pos) {
        let [oPath, oSiblings] = [
            node.path,
            getSiblings(node)
        ];

        // check if move to an invalid target
        for (let d of getDescendants(node)) {
            if (d.id === target.id) {
                throw &quot;Cannot move node to one of its descendants.&quot;
            }
        }

        // insert node to new location
        if (pos === &quot;child&quot;) {
            let newPath = calcPathAppend(target.path, indexToPath(getChildren(target).length + 1));
            updatePath(node, newPath);
        }
        else if (pos === &quot;left&quot; || pos === &quot;right&quot;) {
            let newPath = pos === &quot;left&quot; ? target.path : calcPathShift(target.path, 1);
            updatePath(node, newPath);

            for (let s of getSiblings(target)) {
                if (getPathIndex(s.path) &gt;= getPathIndex(newNodePath)) {
                    updatePath(s, calcPathShift(s.path, 1));
                }
            }
        }

        // shift node&#x27;s original location&#x27;s siblings
        for (let s of oSiblings) {
            if (getPathIndex(s.path) &gt; getPathIndex(oPath)) {
                updatePath(s, calcPathShift(s.path, -1));
            }
        }
    }




    /**
     * Helper
     * Gets node by given node&#x27;s id.
     * @param id - given node&#x27;s id
     * @returns {Object} node if found, else undefined
     */
    static getNodeById(id) {
        return this.nodes.find(x =&gt; x.id === id);
    }

    /**
     * Helper
     * Gets firebase reference by given node&#x27;s id.
     * @param id - given node&#x27;s id
     * @returns {Object} firebase reference if found, else null
     */
    static getRefById(id) {
        return this.rootRef.orderByKey().equalTo(id).ref();
    }

    /**
     * Helper
     * Calculates path by shifting given path with specific step.
     */
    static calcPathShift(path, shift) {
        return path.substr(0, path.length - 4) + indexToPath((getPathIndex(path) + shift));
    }

    /**
     * Helper
     * Calculates path by appending a path to a given one.
     */
    static calcPathAppend(path, append) {
        return path + append;
    }

    /**
     * Helper
     * Gets depth of given path.
     */
    static getDepth(path) {
        return path.length / 4;
    }

    /**
     * Helper
     * Gets path at a depth.
     */
    static getPathAtDepth(path, depth) {
        return path.substr(0, depth * 4);
    }

    /**
     * Helper
     * Updates the path of the given node and all of its descendants.
     */
    static updatePath(node, newPath) {
        let descendants = getDescendants(node);

        for (let d of descendants) {
            let dNewPath = newPath + d.path.substr(node.path.length);
            getRefById(d.id).update({ path: dNewPath});
        }
        getRefById(node.id).update({ path: newPath });
    }

    /**
     * Helper
     * Gets parent&#x27;s path value of the given node.
     */
    static getParentPath(node) {
        return node.path.substr(0, node.path.length - 4);
    }

    /**
     * Helper
     * Gets index at given depth.
     * If no depth specified, gets rightmost index.
     */
    static getPathIndex(path, depth) {
        if (depth) {
            return parseInt(path.substr((depth - 1) * 4, 4));
        }
        return parseInt(path.substr(path.length - 4));
    }

    /**
     * Helper
     * Converts index to path format.
     */
    static indexToPath(index) {
        return (10000 + index).toString().substr(1);
    }
}
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
